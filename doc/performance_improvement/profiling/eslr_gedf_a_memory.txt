Filename: /home/abel/PycharmProjects/TFGTests/core/kernel_generator/processor_model.py

Line #    Mem usage    Increment   Line Contents
================================================
    26     56.9 MiB     56.9 MiB   @profile
    27                             def generate_processor_model(tasks_specification: TasksSpecification, cpu_specification: CpuSpecification) \
    28                                     -> ProcessorModel:
    29     56.9 MiB      0.0 MiB       f = 1  # TODO: Check if it's an error
    30     56.9 MiB      0.0 MiB       n = len(tasks_specification.tasks)
    31     56.9 MiB      0.0 MiB       m = cpu_specification.number_of_cores
    32                             
    33                                 # Transition rate
    34     56.9 MiB      0.0 MiB       eta = 100
    35                             
    36                                 # Total of places of the TCPN processor module
    37     56.9 MiB      0.0 MiB       p = m * (2 * n + 1)  # m processors*(n busy places, n exec places, 1 idle place)
    38                             
    39                                 # Total of transitions
    40     56.9 MiB      0.0 MiB       t = m * (2 * n)  # m processors*(n transitions alloc and n tramsition exec)
    41     56.9 MiB      0.0 MiB       t_alloc = n * m  # m processors*(n transitions alloc)
    42                             
    43     56.9 MiB      0.0 MiB       pre = scipy.zeros((p, t))
    44     56.9 MiB      0.0 MiB       post = scipy.zeros((p, t))
    45     56.9 MiB      0.0 MiB       pre_alloc = scipy.zeros((p, t_alloc))
    46     56.9 MiB      0.0 MiB       post_alloc = scipy.zeros((p, t_alloc))
    47     56.9 MiB      0.0 MiB       lambda_vector = scipy.zeros(t)
    48     56.9 MiB      0.0 MiB       lambda_alloc = scipy.zeros(t_alloc)
    49     56.9 MiB      0.0 MiB       pi = scipy.zeros((t, p))
    50     56.9 MiB      0.0 MiB       mo = scipy.zeros((p, 1))  # Different from np.zeros(p), column array
    51     56.9 MiB      0.0 MiB       s_exec = scipy.zeros((n * m, p))
    52     56.9 MiB      0.0 MiB       s_busy = scipy.zeros((n * m, p))
    53                             
    54                                 # Incidence Matrix C construction
    55                                 # numeration of places and the corresponding label in the model for CPU_1:
    56                                 # busy places: p1-pn->p^busy_{1,1},..,p^busy_{n,1}
    57                                 # exec places: pn+1-p2n->p^exec_{1,1},...,p^exec_{n,1}
    58                                 # idle place:  p2n+1->p^idle_1
    59                             
    60     56.9 MiB      0.0 MiB       for k in range(m):
    61     56.9 MiB      0.0 MiB           i = (2 * n + 1) * k
    62                             
    63                                     # Construction of matrix Post and Pre for busy and exec places (connections to transitions alloc and exec)
    64     56.9 MiB      0.0 MiB           pre[i:i + n, 2 * k * n + n: 2 * k * n + 2 * n] = scipy.identity(n)
    65     56.9 MiB      0.0 MiB           post[i:i + 2 * n, k * 2 * n:k * 2 * n + 2 * n] = scipy.identity(2 * n)
    66                             
    67                                     # Construction of matrix Post and Pre for idle place (connections to transitions alloc and exec)
    68     56.9 MiB      0.0 MiB           pre[(k + 1) * (2 * n + 1) - 1, 2 * k * n: 2 * k * n + n] = eta * scipy.ones(n)
    69     56.9 MiB      0.0 MiB           post[(k + 1) * (2 * n + 1) - 1, 2 * k * n + n: 2 * (k + 1) * n] = eta * scipy.ones(n)
    70                             
    71                                     # Construction of Pre an Post matrix for Transitions alloc
    72     56.9 MiB      0.0 MiB           pre_alloc[i:i + n, k * n: (k + 1) * n] = pre[i:i + n, 2 * k * n: 2 * k * n + n]
    73     56.9 MiB      0.0 MiB           post_alloc[i:i + n, k * n: k * n + n] = post[i:i + n, 2 * k * n: 2 * k * n + n]
    74                             
    75                                     # Execution rates for transitions exec for CPU_k \lambda^exec= eta*F
    76     56.9 MiB      0.0 MiB           lambda_vector[2 * k * n + n:2 * k * n + 2 * n] = eta * f * scipy.ones(n)
    77                             
    78                                     # Execution rates for transitions alloc \lambda^alloc= eta*\lambda^exec
    79     56.9 MiB      0.0 MiB           lambda_vector[2 * k * n:2 * k * n + n] = eta * lambda_vector[2 * k * n + n:2 * k * n + 2 * n]
    80     56.9 MiB      0.0 MiB           lambda_alloc[k * n:(k + 1) * n] = lambda_vector[2 * k * n:2 * k * n + n]
    81                             
    82                                     # Configuration Matrix
    83     56.9 MiB      0.0 MiB           pi[2 * k * n + n:2 * k * n + 2 * n, i:i + n] = scipy.identity(n)
    84                             
    85                                     # Initial condition
    86     56.9 MiB      0.0 MiB           mo[(k + 1) * (2 * n + 1) - 1, 0] = 1
    87                             
    88                                     # Output matrix of the processor model, ( m^exec )
    89     56.9 MiB      0.0 MiB           s_busy[k * n:(k + 1) * n, i:(2 * n + 1) * k + n] = scipy.identity(n)
    90     56.9 MiB      0.0 MiB           s_exec[k * n:(k + 1) * n, (i + 1) + n - 1:(2 * n + 1) * k + 2 * n] = scipy.identity(n)
    91                             
    92     56.9 MiB      0.0 MiB       c = post - pre
    93     56.9 MiB      0.0 MiB       c_alloc = post_alloc - pre_alloc
    94     56.9 MiB      0.0 MiB       lambda_proc = scipy.diag(lambda_vector)
    95                             
    96     57.7 MiB      0.8 MiB       return ProcessorModel(c, lambda_proc, pi, c_alloc, s_exec, s_busy, mo, (c.dot(lambda_proc)).dot(pi))


Filename: /home/abel/PycharmProjects/TFGTests/core/kernel_generator/tasks_model.py

Line #    Mem usage    Increment   Line Contents
================================================
    23     57.7 MiB     57.7 MiB   @profile
    24                             def generate_tasks_model(tasks_specification: TasksSpecification, cpu_specification: CpuSpecification) -> TasksModel:
    25     57.7 MiB      0.0 MiB       n = len(tasks_specification.tasks)
    26     57.7 MiB      0.0 MiB       m = cpu_specification.number_of_cores
    27                             
    28                                 # total of places of the TCPN
    29     57.7 MiB      0.0 MiB       p = 2 * n
    30                             
    31                                 # Total of transitions
    32     57.7 MiB      0.0 MiB       t = n + n * m
    33                             
    34                                 # n transitions of tasks period and n * m transitions alloc
    35     57.7 MiB      0.0 MiB       t_alloc = n * m
    36                             
    37                                 # Incidence Matrix C
    38     57.7 MiB      0.0 MiB       pre = scipy.zeros((p, t))
    39     57.7 MiB      0.0 MiB       post = scipy.zeros((p, t))
    40     57.7 MiB      0.0 MiB       pre_alloc = scipy.zeros((p, t_alloc))
    41     57.7 MiB      0.0 MiB       post_alloc = scipy.zeros((p, t_alloc))
    42     57.7 MiB      0.0 MiB       lambda_vector = scipy.zeros(t)
    43     57.7 MiB      0.0 MiB       pi = scipy.zeros((t, p))
    44     57.7 MiB      0.0 MiB       mo = scipy.zeros((p, 1))
    45                             
    46                                 # Construction of Pre an Post matrix for places(p^w_i,p^cc_i) and transition(t^w_i)
    47     57.7 MiB      0.0 MiB       for k in range(n):
    48     57.7 MiB      0.0 MiB           i = 2 * k
    49     57.7 MiB      0.0 MiB           pre[i, k] = 1
    50     57.7 MiB      0.0 MiB           post[i:i + 2, k] = [1, tasks_specification.tasks[k].c]
    51     57.7 MiB      0.0 MiB           lambda_vector[k] = 1 / tasks_specification.tasks[k].t
    52     57.7 MiB      0.0 MiB           pi[k, i] = 1
    53     57.7 MiB      0.0 MiB           mo[i: i + 2, 0] = [1, tasks_specification.tasks[k].c]
    54                             
    55                                     # Construction of Pre an Post matrix for Transitions alloc
    56     57.7 MiB      0.0 MiB           j = n + k
    57     57.7 MiB      0.0 MiB           while j < t:
    58     57.7 MiB      0.0 MiB               pre[i + 1, j] = 1
    59     57.7 MiB      0.0 MiB               pi[j, i + 1] = 1
    60     57.7 MiB      0.0 MiB               j = j + n
    61                             
    62     57.7 MiB      0.0 MiB       pre_alloc[:, 0: t_alloc] = pre[:, n: t]
    63                             
    64     57.7 MiB      0.0 MiB       c = post - pre
    65     57.7 MiB      0.0 MiB       c_alloc = post_alloc - pre_alloc
    66     57.7 MiB      0.0 MiB       lambda_tau = scipy.diag(lambda_vector)
    67                             
    68     57.7 MiB      0.0 MiB       return TasksModel(c, lambda_tau, pi, c_alloc, mo, (c.dot(lambda_tau)).dot(pi))


Filename: /home/abel/PycharmProjects/TFGTests/core/kernel_generator/thermal_model.py

Line #    Mem usage    Increment   Line Contents
================================================
    22     57.7 MiB     57.7 MiB   @profile
    23                             def simple_conductivity(material_cuboid: MaterialCuboid,
    24                                                     simulation_specification: SimulationSpecification) -> ConductivityModel:
    25                                 """
    26                             
    27                                 :param material_cuboid: Board or CPU
    28                                 :param simulation_specification: Specification
    29                                 :return: Model
    30                                 """
    31     57.7 MiB      0.0 MiB       dx = simulation_specification.step / 1000
    32     57.7 MiB      0.0 MiB       dy = simulation_specification.step / 1000
    33                             
    34     57.7 MiB      0.0 MiB       x: int = round(material_cuboid.x / simulation_specification.step)
    35     57.7 MiB      0.0 MiB       y: int = round(material_cuboid.y / simulation_specification.step)
    36                             
    37     57.7 MiB      0.0 MiB       rho: float = material_cuboid.p
    38     57.7 MiB      0.0 MiB       k: float = material_cuboid.k
    39     57.7 MiB      0.0 MiB       cp: float = material_cuboid.c_p
    40                             
    41                                 # Horizontal lambda and vertical lambda was refactored to achieve more precision
    42     57.7 MiB      0.0 MiB       horizontal_lambda = k / (rho * cp * (dx ** 2))
    43     57.7 MiB      0.0 MiB       vertical_lambda = k / (rho * cp * (dy ** 2))
    44                             
    45                                 # Total number of PN places
    46     57.7 MiB      0.0 MiB       p: int = x * y
    47                             
    48                                 # Total number of transitions
    49     57.7 MiB      0.0 MiB       t: int = 4 * p - 2 * (x + y)
    50                             
    51                                 # C incidence matrix
    52     57.7 MiB      0.0 MiB       i_pre = [[1, 0], [0, 1]]
    53     57.7 MiB      0.0 MiB       i_post = [[0, 1], [1, 0]]
    54                             
    55                                 # The places have been named in snake form
    56                                 # ie. 1 2 3
    57                                 #     6 5 4
    58                                 #     7 8 9 [...]
    59                                 # That is the way to create the incidence matrix with the transitions who connects
    60                                 # 1-2 (both), 2-3 [...], 8-9 until the transition t=[(x*2)*(y-1)] + (x-1)*2
    61     57.7 MiB      0.0 MiB       pre = scipy.zeros((p, t))
    62     57.7 MiB      0.0 MiB       post = scipy.zeros((p, t))
    63                             
    64     57.7 MiB      0.0 MiB       lambda_vector = scipy.zeros(t)
    65                             
    66     63.4 MiB      0.0 MiB       for i in range(p - 1):
    67     63.4 MiB      0.0 MiB           j = i * 2
    68     63.4 MiB      1.0 MiB           pre[i:i + 2, j:j + 2] = i_pre
    69     63.4 MiB      0.0 MiB           post[i:i + 2, j:j + 2] = i_post
    70                             
    71     63.4 MiB      0.0 MiB           lambda_vector[j: j + 2] = [vertical_lambda, vertical_lambda] if (i + 1) % x == 0 else [horizontal_lambda,
    72     63.4 MiB      0.0 MiB                                                                                                  horizontal_lambda]
    73                             
    74                                 # In the next part, we create the transitions that connect 1-6, 2-5, 4-9 y 5-8 (ie. t18 y t17 associated to 1-6)
    75     63.4 MiB      0.0 MiB       v_pre = [1, 0]
    76     63.4 MiB      0.0 MiB       v_post = [0, 1]
    77                             
    78     68.8 MiB      0.0 MiB       for r in range(y - 1):
    79     68.6 MiB      0.0 MiB           i = (r + 2) * x - 1
    80     68.6 MiB      0.0 MiB           u = r * x
    81     68.6 MiB      0.0 MiB           j = 2 * (p - 1 + r * (x - 1))
    82                             
    83     68.8 MiB      0.0 MiB           for _ in range(x - 1):
    84     68.8 MiB      0.3 MiB               pre[u, j: j + 2] = v_pre
    85     68.8 MiB      0.3 MiB               pre[i, j: j + 2] = v_post
    86                             
    87     68.8 MiB      0.3 MiB               post[u, j: j + 2] = v_post
    88     68.8 MiB      0.0 MiB               post[i, j: j + 2] = v_pre
    89                             
    90     68.8 MiB      0.0 MiB               lambda_vector[j: j + 2] = [vertical_lambda, vertical_lambda]
    91                             
    92     68.8 MiB      0.0 MiB               i = i - 1
    93     68.8 MiB      0.0 MiB               j = j + 2
    94     68.8 MiB      0.0 MiB               u = u + 1
    95                             
    96     68.8 MiB      0.0 MiB       return ConductivityModel(pre, post, t, p, lambda_vector)


Filename: /home/abel/PycharmProjects/TFGTests/core/kernel_generator/thermal_model.py

Line #    Mem usage    Increment   Line Contents
================================================
    22     68.8 MiB     68.8 MiB   @profile
    23                             def simple_conductivity(material_cuboid: MaterialCuboid,
    24                                                     simulation_specification: SimulationSpecification) -> ConductivityModel:
    25                                 """
    26                             
    27                                 :param material_cuboid: Board or CPU
    28                                 :param simulation_specification: Specification
    29                                 :return: Model
    30                                 """
    31     68.8 MiB      0.0 MiB       dx = simulation_specification.step / 1000
    32     68.8 MiB      0.0 MiB       dy = simulation_specification.step / 1000
    33                             
    34     68.8 MiB      0.0 MiB       x: int = round(material_cuboid.x / simulation_specification.step)
    35     68.8 MiB      0.0 MiB       y: int = round(material_cuboid.y / simulation_specification.step)
    36                             
    37     68.8 MiB      0.0 MiB       rho: float = material_cuboid.p
    38     68.8 MiB      0.0 MiB       k: float = material_cuboid.k
    39     68.8 MiB      0.0 MiB       cp: float = material_cuboid.c_p
    40                             
    41                                 # Horizontal lambda and vertical lambda was refactored to achieve more precision
    42     68.8 MiB      0.0 MiB       horizontal_lambda = k / (rho * cp * (dx ** 2))
    43     68.8 MiB      0.0 MiB       vertical_lambda = k / (rho * cp * (dy ** 2))
    44                             
    45                                 # Total number of PN places
    46     68.8 MiB      0.0 MiB       p: int = x * y
    47                             
    48                                 # Total number of transitions
    49     68.8 MiB      0.0 MiB       t: int = 4 * p - 2 * (x + y)
    50                             
    51                                 # C incidence matrix
    52     68.8 MiB      0.0 MiB       i_pre = [[1, 0], [0, 1]]
    53     68.8 MiB      0.0 MiB       i_post = [[0, 1], [1, 0]]
    54                             
    55                                 # The places have been named in snake form
    56                                 # ie. 1 2 3
    57                                 #     6 5 4
    58                                 #     7 8 9 [...]
    59                                 # That is the way to create the incidence matrix with the transitions who connects
    60                                 # 1-2 (both), 2-3 [...], 8-9 until the transition t=[(x*2)*(y-1)] + (x-1)*2
    61     68.8 MiB      0.0 MiB       pre = scipy.zeros((p, t))
    62     68.8 MiB      0.0 MiB       post = scipy.zeros((p, t))
    63                             
    64     68.8 MiB      0.0 MiB       lambda_vector = scipy.zeros(t)
    65                             
    66     68.8 MiB      0.0 MiB       for i in range(p - 1):
    67     68.8 MiB      0.0 MiB           j = i * 2
    68     68.8 MiB      0.0 MiB           pre[i:i + 2, j:j + 2] = i_pre
    69     68.8 MiB      0.0 MiB           post[i:i + 2, j:j + 2] = i_post
    70                             
    71     68.8 MiB      0.0 MiB           lambda_vector[j: j + 2] = [vertical_lambda, vertical_lambda] if (i + 1) % x == 0 else [horizontal_lambda,
    72     68.8 MiB      0.0 MiB                                                                                                  horizontal_lambda]
    73                             
    74                                 # In the next part, we create the transitions that connect 1-6, 2-5, 4-9 y 5-8 (ie. t18 y t17 associated to 1-6)
    75     68.8 MiB      0.0 MiB       v_pre = [1, 0]
    76     68.8 MiB      0.0 MiB       v_post = [0, 1]
    77                             
    78     68.8 MiB      0.0 MiB       for r in range(y - 1):
    79     68.8 MiB      0.0 MiB           i = (r + 2) * x - 1
    80     68.8 MiB      0.0 MiB           u = r * x
    81     68.8 MiB      0.0 MiB           j = 2 * (p - 1 + r * (x - 1))
    82                             
    83     68.8 MiB      0.0 MiB           for _ in range(x - 1):
    84     68.8 MiB      0.0 MiB               pre[u, j: j + 2] = v_pre
    85     68.8 MiB      0.0 MiB               pre[i, j: j + 2] = v_post
    86                             
    87     68.8 MiB      0.0 MiB               post[u, j: j + 2] = v_post
    88     68.8 MiB      0.0 MiB               post[i, j: j + 2] = v_pre
    89                             
    90     68.8 MiB      0.0 MiB               lambda_vector[j: j + 2] = [vertical_lambda, vertical_lambda]
    91                             
    92     68.8 MiB      0.0 MiB               i = i - 1
    93     68.8 MiB      0.0 MiB               j = j + 2
    94     68.8 MiB      0.0 MiB               u = u + 1
    95                             
    96     68.8 MiB      0.0 MiB       return ConductivityModel(pre, post, t, p, lambda_vector)


Filename: /home/abel/PycharmProjects/TFGTests/core/kernel_generator/thermal_model.py

Line #    Mem usage    Increment   Line Contents
================================================
    98     93.7 MiB     93.7 MiB   @profile
    99                             def add_interactions_layer(rel_micro: scipy.ndarray, pre_sis: scipy.ndarray, post_sis: scipy.ndarray,
   100                                                        lambda_vector: scipy.ndarray,
   101                                                        board_conductivity: ConductivityModel, cpu_specification: CpuSpecification) -> \
   102                                     [scipy.ndarray, scipy.ndarray, scipy.ndarray]:
   103     93.7 MiB      0.0 MiB       rho_p1 = cpu_specification.board.p
   104     93.7 MiB      0.0 MiB       k_p1 = cpu_specification.board.k
   105     93.7 MiB      0.0 MiB       cp_p1 = cpu_specification.board.c_p
   106                             
   107     93.7 MiB      0.0 MiB       rho_p2 = cpu_specification.cpu_core.p
   108     93.7 MiB      0.0 MiB       k_p2 = cpu_specification.cpu_core.k
   109     93.7 MiB      0.0 MiB       cp_p2 = cpu_specification.cpu_core.c_p
   110                             
   111                                 # Refactored to improve precision
   112     93.7 MiB      0.0 MiB       lambda1 = (k_p1 * k_p2 / (cpu_specification.board.z * rho_p1 * cp_p1 * (
   113     93.7 MiB      0.0 MiB               k_p2 * cpu_specification.board.z + k_p1 * cpu_specification.cpu_core.z))) * (2 * (1000 ** 2))
   114                             
   115     93.7 MiB      0.0 MiB       lambda2 = (k_p1 * k_p2 / (cpu_specification.cpu_core.z * rho_p2 * cp_p2 * (
   116     93.7 MiB      0.0 MiB               k_p2 * cpu_specification.board.z + k_p1 * cpu_specification.cpu_core.z))) * (2 * (1000 ** 2))
   117                             
   118     93.7 MiB      0.0 MiB       lambda1_div_lambda2 = (cpu_specification.cpu_core.z * rho_p2 * cp_p2) / (cpu_specification.board.z * rho_p1 * cp_p1)
   119     93.7 MiB      0.0 MiB       lambda2_div_lambda1 = (cpu_specification.board.z * rho_p1 * cp_p1) / (cpu_specification.cpu_core.z * rho_p2 * cp_p2)
   120                             
   121     93.7 MiB      0.0 MiB       l_lug = len(rel_micro)
   122                             
   123     93.7 MiB      0.0 MiB       v_pre = [1, 0]
   124     93.7 MiB      0.0 MiB       v_post = [0, 1]
   125                             
   126     93.7 MiB      0.0 MiB       pre_int = scipy.zeros((len(pre_sis), 2 * l_lug))
   127     94.0 MiB      0.3 MiB       post_int = scipy.zeros((len(post_sis), 2 * l_lug))
   128                             
   129     94.0 MiB      0.0 MiB       lambda_int = scipy.zeros((2 * l_lug, 1))
   130                             
   131     94.2 MiB      0.0 MiB       for i in range(l_lug):
   132     94.2 MiB      0.0 MiB           j = i * 2
   133     94.2 MiB      0.0 MiB           pre_int[rel_micro[i] - 1, j: j + 2] = v_pre
   134     94.2 MiB      0.0 MiB           pre_int[i + board_conductivity.p, j: j + 2] = v_post
   135                             
   136     94.2 MiB      0.3 MiB           post_int[rel_micro[i] - 1, j: j + 2] = [0, lambda1_div_lambda2]
   137     94.2 MiB      0.0 MiB           post_int[i + board_conductivity.p, j: j + 2] = [lambda2_div_lambda1, 0]
   138                             
   139     94.2 MiB      0.0 MiB           lambda_int[j: j + 2, 0] = [lambda1, lambda2]
   140                             
   141    108.0 MiB     13.8 MiB       pre_sis = scipy.concatenate((pre_sis, pre_int), axis=1)
   142    121.7 MiB     13.7 MiB       post_sis = scipy.concatenate((post_sis, post_int), axis=1)
   143                             
   144    121.7 MiB      0.0 MiB       lambda_vector = scipy.concatenate((lambda_vector, lambda_int))
   145                             
   146    121.7 MiB      0.0 MiB       return pre_sis, post_sis, lambda_vector


Filename: /home/abel/PycharmProjects/TFGTests/core/kernel_generator/thermal_model.py

Line #    Mem usage    Increment   Line Contents
================================================
   148     96.7 MiB     96.7 MiB   @profile
   149                             def add_convection(pre_sis, post_sis, lambda_vector, board_conductivity: ConductivityModel,
   150                                                micro_conductivity: ConductivityModel, cpu_specification: CpuSpecification,
   151                                                environment_specification: EnvironmentSpecification) -> [scipy.ndarray, scipy.ndarray, scipy.ndarray,
   152                                                                                                         scipy.ndarray]:
   153     96.7 MiB      0.0 MiB       rho_p1 = cpu_specification.board.p
   154     96.7 MiB      0.0 MiB       cp_p1 = cpu_specification.board.c_p
   155                             
   156     96.7 MiB      0.0 MiB       h = environment_specification.h
   157                             
   158     96.7 MiB      0.0 MiB       lambda_1 = (h / (cpu_specification.board.z * rho_p1 * cp_p1)) * 1000
   159                             
   160     96.7 MiB      0.0 MiB       lambda_convection = [lambda_1, lambda_1]  # TODO: Check, it might be lambda1, lambda2 (Ask authors)
   161                             
   162     96.7 MiB      0.0 MiB       p_micros = micro_conductivity.p * cpu_specification.number_of_cores
   163                             
   164                                 # Number of places exposed at environment temperature
   165     96.7 MiB      0.0 MiB       l_places = board_conductivity.p
   166                             
   167                                 # Places under CPU
   168     96.7 MiB      0.0 MiB       f = len(pre_sis)
   169                             
   170     96.7 MiB      0.0 MiB       cota_micros = l_places - p_micros
   171                             
   172     96.7 MiB      0.0 MiB       post_convection = scipy.concatenate(
   173     96.7 MiB      0.0 MiB           [block_diag(scipy.ones((cota_micros, 1)), scipy.ones((l_places - cota_micros, 1))),
   174     96.7 MiB      0.0 MiB            scipy.zeros((f - l_places, 2))])
   175                             
   176    102.3 MiB      5.6 MiB       pre_it = scipy.concatenate([scipy.diag(scipy.ones(l_places)), scipy.zeros((f - l_places, l_places))])
   177    102.6 MiB      0.3 MiB       post_it = scipy.zeros((f, l_places))
   178                             
   179    102.6 MiB      0.0 MiB       lambda_it = scipy.ones((l_places, 1)) * lambda_1
   180                             
   181    102.6 MiB      0.0 MiB       pi = [1, 1]
   182                             
   183    119.6 MiB     17.0 MiB       pre_sis = scipy.concatenate((pre_sis, pre_it), axis=1)
   184    136.5 MiB     16.9 MiB       post_sis = scipy.concatenate((post_sis, post_it), axis=1)
   185                             
   186    136.5 MiB      0.0 MiB       lambda_vector = scipy.concatenate((lambda_vector, lambda_it))
   187                             
   188    136.5 MiB      0.0 MiB       return post_convection.dot(scipy.diag(lambda_convection)).dot(
   189    136.5 MiB      0.0 MiB           pi), pre_sis, post_sis, lambda_vector


Filename: /home/abel/PycharmProjects/TFGTests/core/kernel_generator/thermal_model.py

Line #    Mem usage    Increment   Line Contents
================================================
   191    109.4 MiB    109.4 MiB   @profile
   192                             def add_heat(pre_sis, post_sis, board_conductivity: ConductivityModel,
   193                                          micro_conductivity: ConductivityModel, cpu_specification: CpuSpecification,
   194                                          task_specification: TasksSpecification) \
   195                                     -> [scipy.ndarray, scipy.ndarray, scipy.ndarray, scipy.ndarray]:
   196    109.4 MiB      0.0 MiB       rho = cpu_specification.cpu_core.p
   197    109.4 MiB      0.0 MiB       cp = cpu_specification.cpu_core.c_p
   198                             
   199                                 # The generation is equal for each place in the same processor so lambdas are equal too
   200    109.4 MiB      0.0 MiB       lambda_gen = scipy.ones(len(task_specification.tasks) * cpu_specification.number_of_cores)
   201                             
   202    109.4 MiB      0.0 MiB       for j in range(cpu_specification.number_of_cores):
   203    109.4 MiB      0.0 MiB           for i in range(len(task_specification.tasks)):
   204    109.4 MiB      0.0 MiB               lambda_gen[i] = cpu_specification.clock_frequency
   205                                         # FIXME: Cambiar Actualmente estoy suponiendo frecuencia uniforme
   206                                         # Por otro lado, se esta quedando siempre la frecuencia del ultimo procesador, el bucle no tiene sentido,
   207                                         # creo que debería de ser (i - 1) * (j - 1)
   208                                         # Pero en el codigo original a cada lugar se le asigna la frecuencia de cada
   209                                         # procesador Lambda_gen(i)=F(j);
   210                             
   211    109.4 MiB      0.0 MiB       places_proc = list(range(board_conductivity.p + 1,
   212    109.4 MiB      0.0 MiB                                board_conductivity.p + cpu_specification.number_of_cores * micro_conductivity.p + 1))
   213                             
   214    109.4 MiB      0.0 MiB       l_places = len(places_proc)
   215                             
   216    109.4 MiB      0.0 MiB       f = len(pre_sis)
   217                             
   218    109.4 MiB      0.0 MiB       pre_gen = scipy.zeros((f, len(task_specification.tasks) * cpu_specification.number_of_cores))
   219    109.4 MiB      0.0 MiB       post_gen = scipy.zeros((f, len(task_specification.tasks) * cpu_specification.number_of_cores))
   220                             
   221    109.4 MiB      0.0 MiB       j = 1
   222    109.4 MiB      0.0 MiB       for i in range(l_places):
   223    109.4 MiB      0.0 MiB           for k in range(len(task_specification.tasks)):
   224    109.4 MiB      0.0 MiB               post_gen[places_proc[i] - 1, j + k - 1] = (task_specification.tasks[k].e / (rho * cp)) * ((1000 ** 3) / (
   225    109.4 MiB      0.0 MiB                       cpu_specification.cpu_core.x * cpu_specification.cpu_core.y * cpu_specification.cpu_core.z))
   226                             
   227    109.4 MiB      0.0 MiB           if (i + 1) % micro_conductivity.p == 0:
   228    109.4 MiB      0.0 MiB               j = j + len(task_specification.tasks)
   229                             
   230    126.2 MiB     16.8 MiB       pre_sis = scipy.concatenate((pre_sis, pre_gen), axis=1)
   231    143.2 MiB     17.0 MiB       post_sis = scipy.concatenate((post_sis, post_gen), axis=1)
   232                             
   233    143.2 MiB      0.0 MiB       cp_exec = post_gen.dot(scipy.diag(lambda_gen))
   234                             
   235    143.2 MiB      0.0 MiB       return cp_exec, lambda_gen, pre_sis, post_sis


Filename: /home/abel/PycharmProjects/TFGTests/core/kernel_generator/thermal_model.py

Line #    Mem usage    Increment   Line Contents
================================================
   278     57.7 MiB     57.7 MiB   @profile
   279                             def generate_thermal_model(tasks_specification: TasksSpecification, cpu_specification: CpuSpecification,
   280                                                        environment_specification: EnvironmentSpecification,
   281                                                        simulation_specification: SimulationSpecification) -> ThermalModel:
   282                                 # Board and micros conductivity
   283     68.8 MiB     11.1 MiB       board_conductivity = simple_conductivity(cpu_specification.board, simulation_specification)
   284     68.8 MiB      0.0 MiB       micro_conductivity = simple_conductivity(cpu_specification.cpu_core, simulation_specification)
   285                             
   286                                 # Number of places for all CPUs
   287     68.8 MiB      0.0 MiB       p_micros = micro_conductivity.p * cpu_specification.number_of_cores
   288                             
   289                                 # Create pre, post and lambda from the system with board and number of CPUs
   290     68.8 MiB      0.0 MiB       r_pre = board_conductivity.p + p_micros
   291     68.8 MiB      0.0 MiB       c_pre = board_conductivity.t + cpu_specification.number_of_cores * micro_conductivity.t
   292                             
   293     68.8 MiB      0.0 MiB       pre_sis: scipy.ndarray = scipy.zeros((r_pre, c_pre))
   294     81.1 MiB     12.2 MiB       pre_sis[0:board_conductivity.p, 0:board_conductivity.t] = board_conductivity.pre
   295                             
   296     81.1 MiB      0.0 MiB       post_sis: scipy.ndarray = scipy.zeros((r_pre, c_pre))
   297     93.3 MiB     12.2 MiB       post_sis[0:board_conductivity.p, 0:board_conductivity.t] = board_conductivity.post
   298                             
   299     93.3 MiB      0.0 MiB       lambda_vector = scipy.zeros((c_pre, 1))
   300     93.3 MiB      0.0 MiB       lambda_vector[0:board_conductivity.t, 0] = board_conductivity.lambda_vector
   301                             
   302     93.7 MiB      0.0 MiB       for i in range(cpu_specification.number_of_cores):
   303     93.5 MiB      0.0 MiB           r_in = board_conductivity.p + micro_conductivity.p * i
   304     93.5 MiB      0.0 MiB           r_fin = board_conductivity.p + micro_conductivity.p * (i + 1)
   305                             
   306     93.5 MiB      0.0 MiB           c_in = board_conductivity.t + micro_conductivity.t * i
   307     93.5 MiB      0.0 MiB           c_fin = board_conductivity.t + micro_conductivity.t * (i + 1)
   308                             
   309     93.7 MiB      0.3 MiB           pre_sis[r_in: r_fin, c_in: c_fin] = micro_conductivity.pre
   310     93.7 MiB      0.2 MiB           post_sis[r_in: r_fin, c_in: c_fin] = micro_conductivity.post
   311                             
   312     93.7 MiB      0.0 MiB           lambda_vector[c_in:c_fin, 0] = micro_conductivity.lambda_vector
   313                             
   314                                 # Add transitions between micro and board
   315                                 # Connections between micro places and board places
   316     93.7 MiB      0.0 MiB       rel_micro = scipy.zeros(p_micros, dtype=int)
   317                             
   318     93.7 MiB      0.0 MiB       for i in range(cpu_specification.number_of_cores):
   319     93.7 MiB      0.0 MiB           rel_micro[i * micro_conductivity.p: (i + 1) * micro_conductivity.p] = getCpuCoordinates(
   320     93.7 MiB      0.0 MiB               cpu_specification.cpu_origins[i],
   321     93.7 MiB      0.0 MiB               cpu_specification.cpu_core,
   322     93.7 MiB      0.0 MiB               cpu_specification.board,
   323     93.7 MiB      0.0 MiB               simulation_specification)
   324                             
   325                                 # Pre,Post,lambda
   326     93.7 MiB      0.0 MiB       pre_sis, post_sis, lambda_vector = add_interactions_layer(rel_micro, pre_sis, post_sis, lambda_vector,
   327     96.7 MiB      3.0 MiB                                                                 board_conductivity, cpu_specification)
   328                             
   329                                 # Convection
   330     96.7 MiB      0.0 MiB       diagonal, pre_sis, post_sis, lambda_vector = add_convection(pre_sis, post_sis, lambda_vector,
   331     96.7 MiB      0.0 MiB                                                                   board_conductivity, micro_conductivity,
   332    109.4 MiB     12.7 MiB                                                                   cpu_specification, environment_specification)
   333                             
   334                                 # Heat generation
   335    109.4 MiB      0.0 MiB       cp_exec, lambda_generated, pre_sis, post_sis = add_heat(pre_sis, post_sis, board_conductivity, micro_conductivity,
   336    109.5 MiB      0.1 MiB                                                               cpu_specification, tasks_specification)
   337                             
   338    109.5 MiB      0.0 MiB       lambda_vector = scipy.concatenate((lambda_vector, lambda_generated.reshape((-1, 1))))
   339                             
   340                                 # Lineal system
   341    109.5 MiB      0.0 MiB       pi = pre_sis.transpose()
   342    111.8 MiB      2.4 MiB       a = ((post_sis - pre_sis).dot(scipy.diag(lambda_vector.reshape(-1)))).dot(pi)
   343                             
   344                                 # Output places
   345    111.8 MiB      0.0 MiB       l_measurement = scipy.zeros(cpu_specification.number_of_cores, dtype=scipy.int64)
   346                             
   347    111.8 MiB      0.0 MiB       for i in range(cpu_specification.number_of_cores):
   348    111.8 MiB      0.0 MiB           l_measurement[i] = board_conductivity.p + i * micro_conductivity.p + scipy.math.ceil(micro_conductivity.p / 2)
   349                             
   350    111.8 MiB      0.0 MiB       c = scipy.zeros((cpu_specification.number_of_cores, len(a)))
   351                             
   352    111.8 MiB      0.0 MiB       for i in range(cpu_specification.number_of_cores):
   353    111.8 MiB      0.0 MiB           c[i, l_measurement[i] - 1] = 1
   354                             
   355    111.8 MiB      0.0 MiB       return ThermalModel(a, cp_exec, c, diagonal, lambda_generated)


Filename: /home/abel/PycharmProjects/TFGTests/core/schedulers/abstract_global_scheduler.py

Line #    Mem usage    Increment   Line Contents
================================================
    35     76.1 MiB     76.1 MiB       @profile
    36                                 def simulate(self, global_specification: GlobalSpecification,
    37                                              simulation_kernel: SimulationKernel, progress_bar: Optional[AbstractProgressBar]) -> SchedulerResult:
    38                             
    39                                     # True if simulation must save temperature
    40     76.1 MiB      0.0 MiB           is_thermal_simulation = simulation_kernel.thermal_model is not None
    41                             
    42     76.1 MiB      0.0 MiB           idle_task_id = -1
    43     76.1 MiB      0.0 MiB           m = global_specification.cpu_specification.number_of_cores
    44     76.1 MiB      0.0 MiB           n = len(global_specification.tasks_specification.tasks)
    45     76.1 MiB      0.0 MiB           cpu_utilization = sum(map(lambda a: a.c / a.t, global_specification.tasks_specification.tasks))
    46                             
    47                                     # Exit program if can schedule
    48     76.1 MiB      0.0 MiB           if cpu_utilization >= m:
    49                                         raise Exception("Error: Schedule is not feasible")
    50                             
    51                                     # Tasks set
    52     76.1 MiB      0.0 MiB           tasks = [GlobalSchedulerTask(global_specification.tasks_specification.tasks[i], i) for i in
    53     76.1 MiB      0.0 MiB                    range(len(global_specification.tasks_specification.tasks))]
    54                             
    55                                     # Number of steps in the simulation
    56     76.1 MiB      0.0 MiB           simulation_time_steps = int(round(
    57     76.1 MiB      0.0 MiB               global_specification.tasks_specification.h / global_specification.simulation_specification.dt))
    58                             
    59                                     # Allocation of each task in each simulation step
    60     76.1 MiB      0.0 MiB           i_tau_disc = scipy.zeros((n * m, simulation_time_steps))
    61                             
    62                                     # Time of each quantum
    63     76.1 MiB      0.0 MiB           time_step = simulation_time_steps * [0]
    64                             
    65                                     # Accumulated execution time
    66     76.1 MiB      0.0 MiB           m_exec = scipy.ndarray((n * m, simulation_time_steps))
    67                             
    68                                     # Accumulated execution time tcpn
    69     76.1 MiB      0.0 MiB           m_exec_tcpn = scipy.ndarray((n * m, simulation_time_steps))
    70                             
    71                                     # Temperature of cores in each step
    72     76.1 MiB      0.0 MiB           temperature_disc = scipy.ndarray((m, 0))
    73                             
    74                                     # Map with temperatures in each step
    75     76.1 MiB      0.0 MiB           temperature_map = scipy.zeros((len(simulation_kernel.mo), 0))
    76                             
    77                                     # Time where each temperature step have been obtained
    78     76.1 MiB      0.0 MiB           time_temp = scipy.ndarray((0, 1))
    79                             
    80                                     # Initial marking
    81     76.1 MiB      0.0 MiB           mo = simulation_kernel.mo
    82                             
    83                                     # Accumulated execution time in each step
    84     76.1 MiB      0.0 MiB           m_exec_step = scipy.zeros(n * m)
    85                             
    86                                     # Actual cores temperature in each step
    87                                     cores_temperature = scipy.asarray(
    88     76.1 MiB      0.0 MiB               m * [global_specification.environment_specification.t_env]) if is_thermal_simulation else None
    89                             
    90                                     # Active tasks
    91     76.1 MiB      0.0 MiB           active_task_id = m * [-1]
    92    130.2 MiB      0.0 MiB           for zeta_q in range(simulation_time_steps):
    93                                         # Update progress
    94    130.2 MiB      0.0 MiB               if progress_bar is not None:
    95                                             progress_bar.update_progress(zeta_q / simulation_time_steps * 100)
    96                             
    97                                         # Update time
    98    130.2 MiB      0.0 MiB               time = zeta_q * global_specification.simulation_specification.dt
    99                             
   100                                         # Get active task in this step
   101    130.2 MiB      0.0 MiB               active_task_id = self.schedule_policy(time, tasks, m, active_task_id, cores_temperature)
   102                             
   103    130.2 MiB      0.0 MiB               for j in range(m):
   104    130.2 MiB      0.0 MiB                   if active_task_id[j] != idle_task_id:
   105    130.2 MiB      0.0 MiB                       if round(tasks[active_task_id[j]].pending_c, 5) > 0:
   106                                                     # Not end yet
   107    130.2 MiB      0.0 MiB                           tasks[active_task_id[j]].pending_c -= global_specification.simulation_specification.dt
   108    130.2 MiB      0.0 MiB                           i_tau_disc[active_task_id[j] + j * n, zeta_q] = 1
   109    130.2 MiB      0.0 MiB                           m_exec_step[active_task_id[j] + j * n] += global_specification.simulation_specification.dt
   110                             
   111                                                 else:
   112                                                     # Ended
   113    126.9 MiB      0.0 MiB                           tasks[active_task_id[j]].instances += 1
   114                             
   115    126.9 MiB      0.0 MiB                           tasks[active_task_id[j]].pending_c = tasks[active_task_id[j]].c
   116                             
   117    126.9 MiB      0.0 MiB                           tasks[active_task_id[j]].next_arrival += tasks[active_task_id[j]].t
   118    126.9 MiB      0.0 MiB                           tasks[active_task_id[j]].next_deadline += tasks[active_task_id[j]].t
   119                             
   120    130.2 MiB      0.0 MiB               if is_thermal_simulation:
   121    130.2 MiB      0.0 MiB                   mo_next, m_exec_disc, _, _, tout_disc, temp_time_disc, temperature_tcpn = solve_global_model(
   122    130.2 MiB      0.0 MiB                       simulation_kernel.global_model,
   123    130.2 MiB      0.0 MiB                       mo.reshape(-1),
   124    130.2 MiB      0.0 MiB                       i_tau_disc[:, zeta_q].reshape(-1),
   125    130.2 MiB      0.0 MiB                       global_specification.environment_specification.t_env,
   126    130.2 MiB      0.3 MiB                       [time, time + global_specification.simulation_specification.dt])
   127                             
   128    130.2 MiB      0.0 MiB                   mo = mo_next
   129    130.2 MiB     12.9 MiB                   temperature_map = scipy.concatenate((temperature_map, temperature_tcpn), axis=1)
   130    130.2 MiB      0.0 MiB                   time_temp = scipy.concatenate((time_temp, tout_disc))
   131                             
   132    130.2 MiB      0.0 MiB                   temperature_disc = scipy.concatenate((temperature_disc, temp_time_disc), axis=1)
   133                             
   134    130.2 MiB      0.0 MiB                   cores_temperature = scipy.transpose(temp_time_disc)[-1] if temp_time_disc.shape[
   135    130.2 MiB      0.0 MiB                                                                                  1] > 0 else cores_temperature
   136                             
   137    130.2 MiB      0.3 MiB                   m_exec_tcpn[:, zeta_q] = m_exec_disc.reshape(-1)
   138                             
   139                                         else:
   140                                             m_exec_tcpn[:, zeta_q] = m_exec_step
   141                             
   142    130.2 MiB      0.2 MiB               m_exec[:, zeta_q] = m_exec_step
   143                             
   144    130.2 MiB      0.0 MiB               time_step[zeta_q] = time
   145                             
   146    122.0 MiB      0.0 MiB           time_step = scipy.asarray(time_step).reshape((-1, 1))
   147    122.0 MiB      0.0 MiB           return SchedulerResult(temperature_map, mo, time_step, i_tau_disc, m_exec, m_exec_tcpn, time_step, time_temp,
   148    122.0 MiB      0.0 MiB                                  scipy.asarray([]), temperature_disc, global_specification.simulation_specification.dt)


Filename: global_edf_affinity_scheduler_test.py

Line #    Mem usage    Increment   Line Contents
================================================
    15     56.9 MiB     56.9 MiB   @profile
    16                             def test_global_edf_scheduler():
    17     56.9 MiB      0.0 MiB       tasks_specification: TasksSpecification = TasksSpecification([Task(2, 4, 6.4),
    18     56.9 MiB      0.0 MiB                                                                     Task(3, 8, 8),
    19     56.9 MiB      0.0 MiB                                                                     Task(3, 12, 9.6)])
    20     56.9 MiB      0.0 MiB       cpu_specification: CpuSpecification = CpuSpecification(MaterialCuboid(x=50, y=50, z=1, p=8933, c_p=385, k=400),
    21     56.9 MiB      0.0 MiB                                                              MaterialCuboid(x=10, y=10, z=2, p=2330, c_p=712, k=148),
    22     56.9 MiB      0.0 MiB                                                              2, 1)
    23                             
    24     56.9 MiB      0.0 MiB       environment_specification: EnvironmentSpecification = EnvironmentSpecification(0.001, 45, 110)
    25                             
    26     56.9 MiB      0.0 MiB       simulation_specification: SimulationSpecification = SimulationSpecification(2, 0.01)
    27                             
    28     57.7 MiB      0.8 MiB       processor_model: ProcessorModel = generate_processor_model(tasks_specification, cpu_specification)
    29                             
    30     57.7 MiB      0.0 MiB       tasks_model: TasksModel = generate_tasks_model(tasks_specification, cpu_specification)
    31                             
    32     57.7 MiB      0.0 MiB       thermal_model: ThermalModel = generate_thermal_model(tasks_specification, cpu_specification,
    33     57.7 MiB      0.0 MiB                                                            environment_specification,
    34     67.8 MiB     10.0 MiB                                                            simulation_specification)
    35                             
    36     76.1 MiB      8.3 MiB       global_model, mo = generate_global_model(tasks_model, processor_model, thermal_model, environment_specification)
    37                             
    38     76.1 MiB      0.0 MiB       simulation_kernel: SimulationKernel = SimulationKernel(tasks_model, processor_model, thermal_model,
    39     76.1 MiB      0.0 MiB                                                              global_model, mo)
    40                             
    41     76.1 MiB      0.0 MiB       global_specification: GlobalSpecification = GlobalSpecification(tasks_specification, cpu_specification,
    42     76.1 MiB      0.0 MiB                                                                       environment_specification,
    43     76.1 MiB      0.0 MiB                                                                       simulation_specification)
    44                             
    45     76.1 MiB      0.0 MiB       scheduler = GlobalEDFAffinityScheduler()
    46                             
    47    122.0 MiB     45.9 MiB       scheduler_simulation = scheduler.simulate(global_specification, simulation_kernel, None)
    48                             
    49    122.0 MiB      0.0 MiB       scheduler_simulation2 = scheduler_simulation


